#!/usr/bin/env bash
echo '  5 Access, Authentication and Authorization' 2>&1 | tee -a $logfile

echo '  5.1 Configure time-based job schedulers' 2>&1 | tee -a $logfile

# echo '  5.1.1 Ensure cron daemon is enabled and running' 2>&1 | tee -a $logfile
# description='- Description:\nThe cron daemon is used to execute batch jobs on the system.\n\nNote: Other methods, such as systemd timers, exist for scheduling jobs. If another method is used, cron should be removed, and the alternate method should be secured in accordance with local site policy.\n\n- Rationale:\nWhile there may not be user jobs that need to be run on the system, the system does have maintenance jobs that may include security monitoring that have to run, and cron is used to execute them.'

# echo '  5.1.2 Ensure permissions on /etc/crontab are configured' 2>&1 | tee -a $logfile
# description='- Description:\nThe /etc/crontab file is used by cron to control its own jobs. The commands in this item make sure that root is the user and group owner of the file and that only the owner can access the file.\n\nNote: Other methods, such as systemd timers, exist for scheduling jobs. If another method is used, cron should be removed, and the alternate method should be secured in accordance with local site policy.\n\n- Rationale:\nThis file contains information on what system jobs are run by cron. Write access to these files could provide unprivileged users with the ability to elevate their privileges. Read access to these files could provide users with the ability to gain insight on system jobs that run on the system and could provide them a way to gain unauthorized privileged access.'

# echo '  5.1.3 Ensure permissions on /etc/cron.hourly are configured' 2>&1 | tee -a $logfile
# description='- Description:\nThis directory contains system cron jobs that need to run on an hourly basis. The files in this directory cannot be manipulated by the crontab command, but are instead edited by system administrators using a text editor. The commands below restrict read/write and search access to user and group root, preventing regular users from accessing this directory.\n\nNote: Other methods, such as systemd timers, exist for scheduling jobs. If another method is used, cron should be removed, and the alternate method should be secured in accordance with local site policy.\n\n- Rationale:\nGranting write access to this directory for non-privileged users could provide them the means for gaining unauthorized elevated privileges. Granting read access to this directory could give an unprivileged user insight in how to gain elevated privileges or circumvent auditing controls.'

# echo '  5.1.4 Ensure permissions on /etc/cron.daily are configured' 2>&1 | tee -a $logfile
# description='- Description:\nThe /etc/cron.daily directory contains system cron jobs that need to run on a daily basis. The files in this directory cannot be manipulated by the crontab command, but are instead edited by system administrators using a text editor. The commands below restrict read/write and search access to user and group root, preventing regular users from accessing this directory.\n\nNote: Other methods, such as systemd timers, exist for scheduling jobs. If another method is used, cron should be removed, and the alternate method should be secured in accordance with local site policy.\n\n- Rationale:\nGranting write access to this directory for non-privileged users could provide them the means for gaining unauthorized elevated privileges. Granting read access to this directory could give an unprivileged user insight in how to gain elevated privileges or circumvent auditing controls.'

# echo '  5.1.5 Ensure permissions on /etc/cron.weekly are configured' 2>&1 | tee -a $logfile
# description='- Description:\nThe /etc/cron.weekly directory contains system cron jobs that need to run on a weekly basis. The files in this directory cannot be manipulated by the crontab command, but are instead edited by system administrators using a text editor. The commands below restrict read/write and search access to user and group root, preventing regular users from accessing this directory.\n\nNote: Other methods, such as systemd timers, exist for scheduling jobs. If another method is used, cron should be removed, and the alternate method should be secured in accordance with local site policy.\n\n- Rationale:\nGranting write access to this directory for non-privileged users could provide them the means for gaining unauthorized elevated privileges. Granting read access to this directory could give an unprivileged user insight in how to gain elevated privileges or circumvent auditing controls.'

# echo '  5.1.6 Ensure permissions on /etc/cron.monthly are configured' 2>&1 | tee -a $logfile
# description='- Description:\nThe /etc/cron.monthly directory contains system cron jobs that need to run on a monthly basis. The files in this directory cannot be manipulated by the crontab command, but are instead edited by system administrators using a text editor. The commands below restrict read/write and search access to user and group root, preventing regular users from accessing this directory.\n\nNote: Other methods, such as systemd timers, exist for scheduling jobs. If another method is used, cron should be removed, and the alternate method should be secured in accordance with local site policy.\n\n- Rationale:\nGranting write access to this directory for non-privileged users could provide them the means for gaining unauthorized elevated privileges. Granting read access to this directory could give an unprivileged user insight in how to gain elevated privileges or circumvent auditing controls.'

# echo '  5.1.7 Ensure permissions on /etc/cron.d are configured' 2>&1 | tee -a $logfile
# description='- Description:\nThe /etc/cron.d directory contains system cron jobs that need to run in a similar manner to the hourly, daily weekly and monthly jobs from /etc/crontab, but require more granular control as to when they run. The files in this directory cannot be manipulated by the crontab command, but are instead edited by system administrators using a text editor. The commands below restrict read/write and search access to user and group root, preventing regular users from accessing this directory.\n\nNote: Other methods, such as systemd timers, exist for scheduling jobs. If another method is used, cron should be removed, and the alternate method should be secured in accordance with local site policy.\n\n- Rationale:\nGranting write access to this directory for non-privileged users could provide them the means for gaining unauthorized elevated privileges. Granting read access to this directory could give an unprivileged user insight in how to gain elevated privileges or circumvent auditing controls.'

# echo '  5.1.8 Ensure cron is restricted to authorized users' 2>&1 | tee -a $logfile
# description='- Description:\nConfigure /etc/cron.allow to allow specific users to use this service. If /etc/cron.allow does not exist, then /etc/cron.deny is checked. Any user not specifically defined in this file is allowed to use cron. By removing the file, only users in /etc/cron.allow are allowed to use cron.\n\nNotes:\n  \u2022 Other methods, such as systemd timers, exist for scheduling jobs. If another method is used, cron should be removed, and the alternate method should be secured in accordance with local site policy\n  \u2022 Even though a given user is not listed in cron.allow, cron jobs can still be run as that user\n  \u2022 The cron.allow file only controls administrative access to the crontab command for scheduling and modifying cron jobs\n\n- Rationale:\nOn many systems, only the system administrator is authorized to schedule cron jobs. Using the cron.allow file to control who can run cron jobs enforces this policy. It is easier to manage an allow list than a deny list. In a deny list, you could potentially add a user ID to the system and forget to add it to the deny files.'

# echo '  5.1.9 Ensure at is restricted to authorized users' 2>&1 | tee -a $logfile
# description='- Description:\nConfigure /etc/at.allow to allow specific users to use this service. If /etc/at.allow does not exist, then /etc/at.deny is checked. Any user not specifically defined in this file is allowed to use at. By removing the file, only users in /etc/at.allow are allowed to use at.\n\nNote: Other methods, such as systemd timers, exist for scheduling jobs. If another method is used, at should be removed, and the alternate method should be secured in accordance with local site policy\n\n- Rationale:\nOn many systems, only the system administrator is authorized to schedule at jobs. Using the at.allow file to control who can run at jobs enforces this policy. It is easier to manage an allow list than a deny list. In a deny list, you could potentially add a user ID to the system and forget to add it to the deny files.'

echo '  5.2 Configure SSH Server' 2>&1 | tee -a $logfile

# echo '  5.2.1 Ensure permissions on /etc/ssh/sshd_config are configured' 2>&1 | tee -a $logfile
# description='- Description:\nThe /etc/ssh/sshd_config file contains configuration specifications for sshd. The command below sets the owner and group of the file to root.\n\n- Rationale:\nThe /etc/ssh/sshd_config file needs to be protected from unauthorized changes by non-privileged users.'

# echo '  5.2.2 Ensure permissions on SSH private host key files are configured' 2>&1 | tee -a $logfile
# description='- Description:\nAn SSH private key is one of two files used in SSH public key authentication. In this authentication method, The possession of the private key is proof of identity. Only a private key that corresponds to a public key will be able to authenticate successfully. The private keys need to be stored and handled carefully, and no copies of the private key should be distributed.\n\n- Rationale:\nIf an unauthorized user obtains the private SSH host key file, the host could be impersonated.'

# echo '  5.2.3 Ensure permissions on SSH public host key files are configured' 2>&1 | tee --append $logfile
# description='- Description:\nAn SSH public key is one of two files used in SSH public key authentication. In this authentication method, a public key is a key that can be used for verifying digital signatures generated using a corresponding private key. Only a public key that corresponds to a private key will be able to authenticate successfully.\n\n- Rationale:\nIf a public host key file is modified by an unauthorized user, the SSH service may be compromised.'

# echo '  5.2.4 Ensure SSH LogLevel is appropriate' 2>&1 | tee --append $logfile
# description='- Description:\nLogLevel gives the verbosity level that is used when logging messages from sshd(8). The possible values are: QUIET, FATAL, ERROR, INFO, VERBOSE, DEBUG, DEBUG1, DEBUG2 and DEBUG3.\n\nNote: The newer OpenSSH releases do not need a verbose mode setting anymore as the required SSH key activity information is written into the syslog by the default OpenSSH config\n\n- Rationale:\nSSH provides several logging levels with varying amounts of verbosity. The DEBUG loglevels are specifically not recommended other than for strictly debugging SSH communications since it provides so much data that it is difficult to identify important security information and may violate the privacy of users.\nLogLevel INFO is the basic level that records login activity of SSH users. In many situations, such as Incident Response, it is important to determine when a particular user was active on a system. The logout record can eliminate those users who disconnected, which helps narrow the field'

# echo '  5.2.5 Ensure SSH X11 forwarding is disabled' 2>&1 | tee --append $logfile
# description='- Description:\nThe X11Forwarding parameter provides the ability to tunnel X11 traffic through the connection to enable remote graphic connections.\n\n- Rationale:\nDisable X11 forwarding unless there is an operational requirement to use X11 applications directly. There is a small risk that the remote X11 servers of users who are logged in via SSH with X11 forwarding could be compromised by other users on the X11 server.\n\nNote that even if X11 forwarding is disabled, users can always install their own forwarders.'

# echo '  5.2.6 Ensure SSH MaxAuthTries is set to 4 or less' 2>&1 | tee --append $logfile
# description='- Description:\nThe MaxAuthTries parameter specifies the maximum number of authentication attempts permitted per connection. When the login failure count reaches half the number, error messages will be written to the syslog file detailing the login failure.\n\nNote: Local site policy may be more restrictive.\n\n- Rationale:\nSetting the MaxAuthTries parameter to a low number will minimize the risk of successful brute force attacks to the SSH server. While the recommended setting is 4, set the number based on site policy.'

# echo '  5.2.7 Ensure SSH IgnoreRhosts is enabled' 2>&1 | tee --append $logfile
# description='- Description:\nThe IgnoreRhosts parameter specifies that .rhosts and .shosts files will not be used in RhostsRSAAuthentication or HostbasedAuthentication.\n\n- Rationale:\nSetting this parameter forces users to enter a password when authenticating with ssh.'

# echo '  5.2.8 Ensure SSH HostbasedAuthentication is disabled' 2>&1 | tee --append $logfile
# description='- Description:\nThe HostbasedAuthentication parameter specifies if authentication is allowed through trusted hosts via the user of .rhosts, or /etc/hosts.equiv, along with successful public key client host authentication. This option only applies to SSH Protocol Version 2.\n\n- Rationale:\nEven though the .rhosts files are ineffective if support is disabled in /etc/pam.conf, disabling the ability to use .rhosts files in SSH provides an additional layer of protection.'

# echo '  5.2.9 Ensure SSH root login is disabled' 2>&1 | tee --append $logfile
# description='- Description:\nThe PermitRootLogin parameter specifies if the root user can log in using ssh. The default is no.\n\n- Rationale:\nDisallowing root logins over SSH requires system admins to authenticate using their own individual account, then escalating to root via sudo or su. This in turn limits opportunity for non-repudiation and provides a clear audit trail in the event of a security incident.'

# echo '  5.2.10 Ensure SSH PermitEmptyPasswords is disabled' 2>&1 | tee --append $logfile
# description='- Description:\nThe PermitEmptyPasswords parameter specifies if the SSH server allows login to accounts with empty password strings.\n\n- Rationale:\nDisallowing remote shell access to accounts that have an empty password reduces the probability of unauthorized access to the system.'

# echo '  5.2.11 Ensure SSH PermitUserEnvironment is disabled' 2>&1 | tee --append $logfile
# description='- Description:\nThe PermitUserEnvironment option allows users to present environment options to the ssh daemon.\n\n- Rationale:\nPermitting users the ability to set environment variables through the SSH daemon could potentially allow users to bypass security controls (e.g. setting an execution path that has ssh executing trojan'"'"'d programs).'

# echo '  5.2.12 Ensure only strong Ciphers are used' 2>&1 | tee --append $logfile
# description='- Description:\nThis variable limits the ciphers that SSH can use during communication.\n\nNotes:\n  \u2022 Some organizations may have stricter requirements for approved ciphers\n  \u2022 Ensure that ciphers used are in compliance with site policy\n  \u2022 The only "strong" ciphers currently FIPS 140-2 compliant are:\n    \u00b0 aes256-ctr\n    \u00b0 aes192-ctr\n    \u00b0 aes128-ctr\n  \u2022 Supported ciphers in openSSH 8.2:\n3des-cbc, aes128-cbc, aes192-cbc, aes256-cbc, aes128-ctr, aes192-ctr, aes256-ctr, aes128-gcm@openssh.com, aes256-gcm@openssh.com, chacha20-poly1305@openssh.com\n\n- Rationale:\nWeak ciphers that are used for authentication to the cryptographic module cannot be relied upon to provide confidentiality or integrity, and system data may be compromised\n  \u2022 The Triple DES ciphers, as used in SSH, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, aka a "Sweet32" attack\n  \u2022 Error handling in the SSH protocol; Client and Server, when using a block cipher algorithm in Cipher Block Chaining (CBC) mode, makes it easier for remote attackers to recover certain plaintext data from an arbitrary block of ciphertext in an SSH session via unknown vectors'

# echo '  5.2.13 Ensure only strong MAC algorithms are used' 2>&1 | tee --append $logfile
# description='- Description:\nThis variable limits the types of MAC algorithms that SSH can use during communication.\n\nNotes:\n  \u2022 Some organizations may have stricter requirements for approved MACs\n  \u2022 Ensure that MACs used are in compliance with site policy\n  \u2022 The only "strong" MACs currently FIPS 140-2 approved are:\n    \u00b0 hmac-sha2-256\n    \u00b0 hmac-sha2-512\n  \u2022 The Supported MACs are:\nhmac-md5, hmac-md5-96, hmac-sha1, hmac-sha1-96, hmac-sha2-256, hmac-sha2-512, umac-64@openssh.com, umac-128@openssh.com, hmac-md5-etm@openssh.com, hmac-md5-96-etm@openssh.com, hmac-sha1-etm@openssh.com, hmac-sha1-96-etm@openssh.com, hmac-sha2-256-etm@openssh.com, hmac-sha2-512-etm@openssh.com, umac-64-etm@openssh.com, umac-128-etm@openssh.com\n\n- Rationale:\nMD5 and 96-bit MAC algorithms are considered weak and have been shown to increase exploitability in SSH downgrade attacks. Weak algorithms continue to have a great deal of attention as a weak spot that can be exploited with expanded computing power. An attacker that breaks the algorithm could take advantage of a MiTM position to decrypt the SSH tunnel and capture credentials and information.'

# echo '  5.2.14 Ensure only strong Key Exchange algorithms are used' 2>&1 | tee --append $logfile
# description='- Description:\nKey exchange is any method in cryptography by which cryptographic keys are exchanged between two parties, allowing use of a cryptographic algorithm. If the sender and receiver wish to exchange encrypted messages, each must be equipped to encrypt messages to be sent and decrypt messages received.\n\nNotes:\n  \u2022 Kex algorithms have a higher preference the earlier they appear in the list\n  \u2022 Some organizations may have stricter requirements for approved Key exchange algorithms\n  \u2022 Ensure that Key exchange algorithms used are in compliance with site policy\n  \u2022 The only Key Exchange Algorithms currently FIPS 140-2 approved are:\n    \u00b0 ecdh-sha2-nistp256\n    \u00b0 ecdh-sha2-nistp384\n    \u00b0 ecdh-sha2-nistp521\n    \u00b0 diffie-hellman-group-exchange-sha256\n    \u00b0 diffie-hellman-group16-sha512\n    \u00b0 diffie-hellman-group18-sha512\n    \u00b0 diffie-hellman-group14-sha256\n  \u2022 The Key Exchange algorithms supported by OpenSSH 8.2 are:\ncurve25519-sha256, curve25519-sha256@libssh.org, diffie-hellman-group1-sha1, diffie-hellman-group14-sha1, diffie-hellman-group14-sha256, diffie-hellman-group16-sha512, diffie-hellman-group18-sha512, diffie-hellman-group-exchange-sha1, diffie-hellman-group-exchange-sha256, ecdh-sha2-nistp256,ecdh-sha2-nistp384, ecdh-sha2-nistp521, sntrup4591761x25519-sha512@tinyssh.org\n\n- Rationale:\nKey exchange methods that are considered weak should be removed. A key exchange method may be weak because too few bits are used, or the hashing algorithm is considered too weak. Using weak algorithms could expose connections to man-in-the-middle attacks.'

# echo '  5.2.15 Ensure SSH Idle Timeout Interval is configured' 2>&1 | tee --append $logfile
# description='- Description:\nThe two options ClientAliveInterval and ClientAliveCountMax control the timeout of ssh sessions.\n  \u2022 ClientAliveInterval sets a timeout interval in seconds after which if no data has been received from the client, sshd will send a message through the encrypted channel to request a response from the client. The default is 0, indicating that these messages will not be sent to the client\n  \u2022 ClientAliveCountMax sets the number of client alive messages which may be sent without sshd receiving any messages back from the client.\nIf this threshold is reached while client alive messages are being sent, sshd will disconnect the client, terminating the session.\nThe default value is 3.\n    \u00b0 The client alive messages are sent through the encrypted channel\n    \u00b0 Setting ClientAliveCountMax to 0 disables connection termination\nExample: If the ClientAliveInterval is set to 15 seconds and the ClientAliveCountMax is set to 3, the client ssh session will be terminated after 45 seconds of idle time.\n\nNote: Local site policy may be more restrictive.\n\n- Rationale:\nHaving no timeout value associated with a connection could allow an unauthorized user access to another user'"'"'s ssh session (e.g. user walks away from their computer and doesn'"'"'t lock the screen). Setting a timeout value reduces this risk.\n  \u2022 The recommended ClientAliveInterval setting is 300 seconds (5 minutes)\n  \u2022 The recommended ClientAliveCountMax setting is 3\n  \u2022 The ssh session would send three keep alive messages at 5 minute intervals. If no response is received after the third keep alive message, the ssh session would be terminated after 15 minutes.'

# echo '  5.2.16 Ensure SSH LoginGraceTime is set to one minute or less' 2>&1 | tee --append $logfile
# description='- Description:\nThe LoginGraceTime parameter specifies the time allowed for successful authentication to the SSH server. The longer the Grace period is the more open unauthenticated connections can exist. Like other session controls in this session the Grace Period should be limited to appropriate organizational limits to ensure the service is available for needed access.\n\nNote: Local site policy may be more restrictive\n\n- Rationale:\nSetting the LoginGraceTime parameter to a low number will minimize the risk of successful brute force attacks to the SSH server. It will also limit the number of concurrent unauthenticated connections While the recommended setting is 60 seconds (1 Minute), set the number based on site policy.'

# echo '  5.2.17 Ensure SSH access is limited' 2>&1 | tee --append $logfile
# description='- Description:\nThere are several options available to limit which users and group can access the system via SSH. It is recommended that at least one of the following options be leveraged:\n  \u2022 AllowUsers - Gives the system administrator the option of allowing specific users to ssh into the system\n    \u00b0 The list consists of space separated user names\n    \u00b0 Numeric user IDs are not recognized with this variable\n    \u00b0 A system administrator may restrict user access further by only allowing the allowed users to log in from a particular host by specifying the entry as <user>@<host>\n  \u2022 AllowGroups - Gives the system administrator the option of allowing specific groups of users to ssh into the system\n    \u00b0 The list consists of space separated group names\n    \u00b0 Numeric group IDs are not recognized with this variable\n  \u2022 DenyUsers - Gives the system administrator the option of denying specific users to ssh into the system\n    \u00b0 The list consists of space separated user names\n    \u00b0 Numeric user IDs are not recognized with this variable\n    \u00b0 If a system administrator wants to restrict user access further by specifically denying a user'"'"'s access from a particular host by specifying the entry as <user>@<host>\n  \u2022 DenyGroups - Gives the system administrator the option of denying specific groups of users to ssh into the system\n    \u00b0 The list consists of space separated group names\n    \u00b0 Numeric group IDs are not recognized with this variable\n\n- Rationale:\nRestricting which users can remotely access the system via SSH will help ensure that only authorized users access the system.'

# echo '  5.2.18 Ensure SSH warning banner is configured' 2>&1 | tee --append $logfile
# description='- Description:\nThe Banner parameter specifies a file whose contents must be sent to the remote user before authentication is permitted. By default, no banner is displayed.\n\n- Rationale:\nBanners are used to warn connecting users of the particular site'"'"'s policy regarding connection. Presenting a warning message prior to the normal user login may assist the prosecution of trespassers on the computer system.'

# echo '  5.2.19 Ensure SSH PAM is enabled' 2>&1 | tee --append $logfile
# description='- Description:\nUsePAM Enables the Pluggable Authentication Module interface. If set to “yes” this will enable PAM authentication using ChallengeResponseAuthentication and PasswordAuthentication in addition to PAM account and session module processing for all authentication types.\n\n- Rationale:\nWhen usePAM is set to yes, PAM runs through account and session types properly. This is important if you want to restrict access to services based off of IP, time or other factors of the account. Additionally, you can make sure users inherit certain environment variables on login or disallow access to the server'

# echo '  5.2.20 Ensure SSH AllowTcpForwarding is disabled' 2>&1 | tee --append $logfile
# description='- Description:\nSSH port forwarding is a mechanism in SSH for tunneling application ports from the client to the server, or servers to clients. It can be used for adding encryption to legacy applications, going through firewalls, and some system administrators and IT professionals use it for opening backdoors into the internal network from their home machines.\n\n- Rationale:\nLeaving port forwarding enabled can expose the organization to security risks and backdoors.\nSSH connections are protected with strong encryption. This makes their contents invisible to most deployed network monitoring and traffic filtering solutions. This invisibility carries considerable risk potential if it is used for malicious purposes such as data exfiltration. Cybercriminals or malware could exploit SSH to hide their unauthorized communications, or to exfiltrate stolen data from the target network'

# echo '  5.2.21 Ensure SSH MaxStartups is configured' 2>&1 | tee --append $logfile
# description='- Description:\nThe MaxStartups parameter specifies the maximum number of concurrent unauthenticated connections to the SSH daemon.\n\nNote: Local site policy may be more restrictive.\n\n- Rationale:\nTo protect a system from denial of service due to a large number of pending authentication connection attempts, use the rate limiting function of MaxStartups to protect availability of sshd logins and prevent overwhelming the daemon.'

# echo '  5.2.22 Ensure SSH MaxSessions is limited' 2>&1 | tee --append $logfile
# description='- Description:\nThe MaxSessions parameter specifies the maximum number of open sessions permitted from a given connection.\n\nNote: Local site policy may be more restrictive.\n\n- Rationale:\nTo protect a system from denial of service due to a large number of concurrent sessions, use the rate limiting function of MaxSessions to protect availability of sshd logins and prevent overwhelming the daemon.'

echo '  5.3 Configure PAM' 2>&1 | tee --append $logfile

echo '  5.3.1 Ensure password creation requirements are configured' 2>&1 | tee --append $logfile
description='- Description:\nThe pam_pwquality.so module checks the strength of passwords. It performs checks such as making sure a password is not a dictionary word, it is a certain length, contains a mix of characters (e.g. alphabet, numeric, other) and more. The following are definitions of the pam_pwquality.so options.\nThe following options are set in the /etc/security/pwquality.conf file:\n  \u2022 Password Length:\n    \u00b0 minlen = 14 - password must be 14 characters or more\n  \u2022 Password complexity:\n    \u00b0 minclass = 4 - The minimum number of required classes of characters for the new password (digits, uppercase, lowercase, others)\n      OR\n    \u00b0 dcredit = -1 - provide at least one digit\n    \u00b0 ucredit = -1 - provide at least one uppercase character\n    \u00b0 ocredit = -1 - provide at least one special character\n    \u00b0 lcredit = -1 - provide at least one lowercase character\nThe following is set in the /etc/pam.d/common-password file:\n  \u2022 retry=3 - Allow 3 tries before sending back a failure. The settings shown above are one possible policy. Alter these values to conform to your own organization'"'"'s password policies.\n\n- Rationale:\nStrong passwords protect systems from being hacked through brute force methods.'

echo '  5.3.2 Ensure lockout for failed password attempts is configured' 2>&1 | tee --append $logfile
description='- Description:\nLock out users after n unsuccessful consecutive login attempts. The first sets of changes are made to the PAM configuration files. The second set of changes are applied to the program specific PAM configuration file. The second set of changes must be applied to each program that will lock out users. Check the documentation for each secondary program for instructions on how to configure them to work with PAM.\n  \u2022 deny=n - n represents the number of failed attempts before the account is locked\n  \u2022 unlock_time=n - n represents the number of seconds before the account is unlocked\n  \u2022 audit - Will log the user name into the system log if the user is not found.\n  \u2022 silent - Don'"'"'t print informative messages. Set the lockout number and unlock time in accordance with local site policy.\n\nNotes:\n  \u2022 Add pam_tally2 to the account section account required pam_tally2.so for the counter to reset to 0 when using sudo\n  \u2022 Use of the "audit" keyword may log credentials in the case of user error during authentication. This risk should be evaluated in the context of the site policies of your organization.\n  \u2022 If a user has been locked out because they have reached the maximum consecutive failure count defined by deny= in the pam_tally2.so module, the user can be unlocked by issuing the command /sbin/pam_tally2 -u <username> --reset. This command sets the failed count to 0, effectively unlocking the user.\n\n- Rationale:\nLocking out user IDs after n unsuccessful consecutive login attempts mitigates brute force password attacks against your systems.'

echo '  5.3.3 Ensure password reuse is limited' 2>&1 | tee --append $logfile
description='- Description:\nThe /etc/security/opasswd file stores the users'"'"' old passwords and can be checked to ensure that users are not recycling recent passwords.\n\nNote: Changes only apply to accounts configured on the local system.\n\n- Rationale:\nForcing users not to reuse their past 5 passwords make it less likely that an attacker will be able to guess the password.'

echo '  5.3.4 Ensure password hashing algorithm is SHA-512' 2>&1 | tee --append $logfile
description='- Description:\nThe commands below change password encryption from md5 to sha512 (a much stronger hashing algorithm). All existing accounts will need to perform a password change to upgrade the stored hashes to the new algorithm.\n\nNotes:\n  \u2022 Additional module options may be set, recommendation only covers those listed here.\n  \u2022 If it is determined that the password algorithm being used is not SHA-512, once it is changed, it is recommended that all user ID'"'"'s be immediately expired and forced to change their passwords on next login\n  \u2022 The following command can be used:\n # awk -F: '"'"'( $3 >= $(awk '"'"'/^\s*UID_MIN/{print $2}'"'"' /etc/login.defs) && $1 !="nfsnobody" ) { print $1 }'"'"' /etc/passwd | xargs -n 1 chage -d 0\n  \u2022 Any system accounts that need to be expired should be carefully done separately by the system administrator to prevent any potential problems.\n\n- Rationale:\n The SHA-512 algorithm provides much stronger hashing than MD5, thus providing additional protection to the system by increasing the level of effort for an attacker to successfully determine passwords.\n Note: These change only apply to accounts configured on the local system.'

echo '  5.4 User Accounts and Environment' 2>&1 | tee --append $logfile

echo '  5.4.1 Set Shadow Password Suite Parameters' 2>&1 | tee --append $logfile

echo '  5.4.1.1 Ensure password expiration is 365 days or less' 2>&1 | tee --append $logfile
description='- Description:\nThe PASS_MAX_DAYS parameter in /etc/login.defs allows an administrator to force passwords to expire once they reach a defined age. It is recommended that the PASS_MAX_DAYS parameter be set to less than or equal to 365 days.\n\nNotes:\n    \u2022 A value of -1 will disable password expiration\n    \u2022 The password expiration must be greater than the minimum days between password changes or users will be unable to change their password.\n\n- Rationale:\nThe window of opportunity for an attacker to leverage compromised credentials or successfully compromise credentials via an online brute force attack is limited by the age of the password. Therefore, reducing the maximum age of a password also reduces anattacker'"'"'s window of opportunity.'

echo '  5.4.1.2 Ensure minimum days between password changes is configured' 2>&1 | tee --append $logfile
description='- Description:\nThe PASS_MIN_DAYS parameter in /etc/login.defs allows an administrator to prevent users from changing their password until a minimum number of days have passed since the last time the user changed their password. It is recommended that PASS_MIN_DAYS parameter be set to 1 or more days.\n\n- Rationale:\nBy restricting the frequency of password changes, an administrator can prevent users from repeatedly changing their password in an attempt to circumvent password reuse controls.'

echo '  5.4.1.3 Ensure password expiration warning days is 7 or more' 2>&1 | tee --append $logfile
description='- Description:\nThe PASS_WARN_AGE parameter in /etc/login.defs allows an administrator to notify users that their password will expire in a defined number of days. It is recommended that the PASS_WARN_AGE parameter be set to 7 or more days.\n\n- Rationale:\nProviding an advance warning that a password will be expiring gives users time to think of a secure password. Users caught unaware may choose a simple password or write it down where it may be discovered.'

echo '  5.4.1.4 Ensure inactive password lock is 30 days or less' 2>&1 | tee --append $logfile
description='- Description:\nUser accounts that have been inactive for over a given period of time can be automatically disabled. It is recommended that accounts that are inactive for 30 days after password expiration be disabled.\n\nNote: A value of -1 would disable this setting.\n\n- Rationale:\nInactive accounts pose a threat to system security since the users are not logging in to notice failed login attempts or other anomalies.'

echo '  5.4.1.5 Ensure all users last password change date is in the past' 2>&1 | tee --append $logfile
description='- Description:\nAll users should have a password change date in the past.\n\n- Rationale:\nIf a users recorded password change date is in the future then they could bypass any set password expiration.'

echo '  5.4.2 Ensure system accounts are secured' 2>&1 | tee --append $logfile
description='- Description:\nThere are a number of accounts provided with most distributions that are used to manage applications and are not intended to provide an interactive shell.\n\n- Rationale:\nIt is important to make sure that accounts that are not being used by regular users are prevented from being used to provide an interactive shell. By default, most distributions set the password field for these accounts to an invalid string, but it is also recommended that the shell field in the password file be set to the nologin shell. This prevents the account from potentially being used to run any commands.'

echo '  5.4.3 Ensure default group for the root account is GID 0' 2>&1 | tee --append $logfile
description='- Description:\nThe usermod command can be used to specify which group the root user belongs to. This affects permissions of files that are created by the root user.\n\n- Rationale:\nUsing GID 0 for the root account helps prevent root -owned files from accidentally becoming accessible to non-privileged users.'

echo '  5.4.4 Ensure default user umask is 027 or more restrictive' 2>&1 | tee --append $logfile
description='- Description:\nThe user file-creation mode mask (umask) is use to determine the file permission for newly created directories and files. In Linux, the default permissions for any newly created directory is 0777 (rwxrwxrwx), and for any newly created file it is 0666 (rw-rw-rw-). The umask modifies the default Linux permissions by restricting (masking) these permissions. The umask is not simply subtracted, but is processed bitwise. Bits set in the umask are cleared in the resulting file mode.\numask can be set with either octal or Symbolic values\n  \u2022 Octal (Numeric) Value - Represented by either three or four digits. ie umask 0027 or umask 027. If a four digit umask is used, the first digit is ignored. The remaining three digits effect the resulting permissions for user, group, and world/other respectively.\n  \u2022 Symbolic Value - Represented by a comma separated list for User u, group g, and world/other \u00b0. The permissions listed are not masked by umask. ie a umask set by umask u=rwx,g=rx,\u00b0= is the Symbolic equivalent of the Octal umask 027. This umask would set a newly created directory with file mode drwxr-x--- and a newly created file with file mode rw-r-----.\nThe pam_umask module will set the umask according to the system default in /etc/login.defs and user settings, solving the problem of different umask settings with different shells, display managers, remote sessions etc. The default umask can also be set in a System Wide Shell Configuration File.\n\nSystem Wide Shell Configuration Files:\n  \u2022 /etc/profile - used to set system wide environmental variables on users shells. The variables are sometimes the same ones that are in the .profile, however this file is used to set an initial PATH or PS1 for all shell users of the system. is only executed for interactive login shells, or shells executed with the --login parameter\n  \u2022 /etc/profile.d - /etc/profile will execute the scripts within /etc/profile.d/*.sh. It is recommended to place your configuration in a shell script within /etc/profile.d to set your own system wide environmental variables.\n  \u2022 /etc/bash.bashrc - System wide version of .bashrc. etc/bashrc also invokes /etc/profile.d/*.sh if non-login shell, but redirects output to /dev/null if noninteractive. Is only executed for interactive shells or if BASH_ENV is set to /etc/bash.bashrc\n\nUser Shell Configuration Files:\n  \u2022 ~/.profile - Is executed to configure your shell before the initial command prompt. Is only read by login shells.\n  \u2022 ~/.bashrc - Is executed for interactive shells. only read by a shell that'"'"'s both interactive and non-login\n\nNotes:\n  \u2022 umask=<mask> value in the /etc/login.defs file is interpreted as Octal\n  \u2022 Other methods of setting a default user umask exist\n  \u2022 If other methods are in use in your environment they should be audited\n  \u2022 The default user umask can be overridden with a user specific umask\n  \u2022 /etc/pam.d/login can be used to set the user specific umask at login\n  \u2022 The user creating the directories or files has the discretion of changing the permissions:\n    \u00b0 Using the chmod command\n    \u00b0 Setting a different default umask by adding the umask command into a User Shell Configuration File, ( .bash_profile or .bash.bashrc), in their home directory\n    \u00b0 Manually changing the umask for the duration of a login session by running the umask command\n\n- Rationale:\nSetting a very secure default value for umask ensures that users make a conscious choice about their file permissions. A default umask setting of 077 causes files and directories created by users to not be readable by any other user on the system. A umask of 027 would make files and directories readable by users in the same Unix group, while a umask of 022 would make files readable by every user on the system'

echo '  5.4.5 Ensure default user shell timeout is 900 seconds or less' 2>&1 | tee --append $logfile
description='- Description:\nTMOUT is an environmental setting that determines the timeout of a shell in seconds.\n  \u2022 TMOUT=n - Sets the shell timeout to n seconds. A setting of TMOUT=0 disables timeout.\n  \u2022 readonly TMOUT- Sets the TMOUT environmental variable as readonly, preventing unwanted modification during run-time.\n  \u2022 export TMOUT - exports the TMOUT variable\n\nSystem Wide Shell Configuration Files:\n  \u2022 /etc/profile - used to set system wide environmental variables on users shells. The variables are sometimes the same ones that are in the .bash_profile, however this file is used to set an initial PATH or PS1 for all shell users of the system. is only executed for interactive login shells, or shells executed with the --login parameter.\n  \u2022 /etc/profile.d - /etc/profile will execute the scripts within /etc/profile.d/*.sh. It is recommended to place your configuration in a shell script within /etc/profile.d to set your own system wide environmental variables.\n  \u2022 /etc/bashrc - System wide version of bash.bashrc. etc/bash.bashrc also invokes /etc/profile.d/*.sh if non-login shell, but redirects output to /dev/null if noninteractive. Is only executed for interactive shells or if BASH_ENV is set to /etc/bash.bashrc.\n\nNotes:\n  \u2022 The audit and remediation in this recommendation apply to bash and shell. If other shells are supported on the system, it is recommended that their configuration files are also checked\n  \u2022 Other methods of setting a timeout exist not covered here\n  \u2022 Ensure that the timeout conforms to your local policy\n\n- Rationale:\nSetting a timeout value reduces the window of opportunity for unauthorized user access to another user'"'"'s shell session that has been left unattended. It also ends the inactive session and releases the resources associated with that session.'

echo '  5.5 Ensure root login is restricted to system console' 2>&1 | tee --append $logfile
description='- Description:\nThe file /etc/securetty contains a list of valid terminals that may be logged in directly as root.\n\n- Rationale:\nSince the system console has special properties to handle emergency situations, it is important to ensure that the console is in a physically secure location and that unauthorized consoles have not been defined.'

echo '  5.6 Ensure access to the su command is restricted' 2>&1 | tee --append $logfile
description='- Description:\nThe su command allows a user to run a command or shell as another user. The program has been superseded by sudo , which allows for more granular control over privileged access. Normally, the su command can be executed by any user. By uncommenting the pam_wheel.so statement in /etc/pam.d/su, the su command will only allow users in a specific groups to execute su. This group should be empty to reinforce the use of sudo for privileged access.\n\n- Rationale:\nRestricting the use of su , and using sudo in its place, provides system administrators better control of the escalation of user privileges to execute privileged commands. The sudo utility also provides a better logging and audit mechanism, as it can log each command executed via sudo , whereas su can only record that a user executed the su program.'
